#汇编语言学习（真的做梦都没想到，居然在看汇编语言）

## &gt;数据传送指令

-----

* **累加器 目的操作数**  
	MOV A,#data/direct/Rn/@Rn ；  
* **寄存器 目的操作书**  
	MOV Rn,direct/Rn/#data;
* **直接地址 目的操作数**  
	MOV direct,#data/direct2/Rn/@Ri;
* **简介寻址 目的操作数**  
	MOV @Ri,#data/direct/Rn;
* **十六位数 传递**  
	MOV DPTR,#DATA16;只有DPTR能被16位赋值。  
	MOV DPTR,#1234H;执行后DPH=12H,DPL=34H;  
* **片外数据传送**  
	MOVX A,@Ri;  
> 只有A累加器可以与外部RAM打交道  
> Ri是八位寄存器，只能存放低八位地址，通过p0口提供高八位  
> 使用前先将地址送入DPTR或者ri中
 
 MOV DPTR,#0100H;  
 MOVX A,@DPTR;   
 MOV DPTR,#0200H;  
 MOVX @DPTR,A;  


* **读取程序存储器指令**  
	MOVC A,@A+DPTR;

* **堆栈操作**  
	PUSH direct；  
	POP direct；  
* **数据交换指令**  
	XCH A Rn；交换值

## &gt; 算数运算类指令

-----

* **无进位加法指令**
	ADD A,#data;A=A+#DATA  
	ADD A,direct;  
* **带进位加法指令**  
	ADDC A,RN;A=A+RN+PSW.CY  
> 对于PSW中CY和OV的介绍  
> 当进行二进制无符号运算时，只要使用PSW.CY位就能判定是否有溢出或者进位。  
> 当进行二进制补码运算时，PSW.CY表示进位，PSW.OV表示是否错误或者溢出。是最高两位的抑或（如果是负数且有溢出CY时，相加后不应该更大，而是更小。如果是整数相加后不应该更小，所以最高两位的抑或ov能够实现是否错误的判定)

* **加一指令**  
	INC A;
* **十进制调整指令**  
	DA A;  
> DA是按照BCD码调整相加后的二进制数。BCD码需要四位二进制来表示，但是这四位的进位，和二进制四位的进位不同（BCD满十进位），导致二进制码相加后并不是规范的BCD码，所以根据PSW.AC进行调整。  

* **带借位的减法指令**  
	SUBB A,RN;A=A-RN-CY  
* **减一指令**  
	DEC A;A=A-1  
* **乘法指令**  
	MUL AB;BA=A*B
> 8位无符号数相乘，两数相乘结果较大，高八位存放在B中，第八位存放在A中。

## &gt;逻辑运算指令

-----

* **逻辑或**  
	ORL A,RN;  
* **逻辑与**  
	ANL A,RN;  
* **逻辑异或**    
	XRL A,RN;  
> 读改写指令对并行端口P0，P1，P2，P3操作是，读取并行端口锁存器中的数据，而非，管处的数据。  
> 非读改写操作，读取引脚处数据，而非锁存器数据。  

* **清零**  
	CLR A;  
* **循环移位**  
	RL A; rotate left  
	RR A; rotate right  
	RLC A; rotate left with cy  
	RRC A; rotate right with cy  

## &gt;控制转移类指令

-----
>特点，不影响psw。实现了分支、循环、调用。是控制程序的相关指令，而非更改数据的指令。


* **无条件转移指令**  
	AJMP addr11;短转移指令，11位地址，指令长度两个字节  
	LJMP addr16;长转移指令，16位地址，指令长度三个字节   
	SJMP rel; 相对转移指令，8位二进制补码地址  
	JMP @A+DPTR;间接转移指令  
> 以上指令通过间接修改pc值实现。前两条直接给出类跳转的目标地址。短转移指令只修改PC的低八位地址，高五位不变，转移范围2kB；长转移指令，转移范围64KB；相对转移指令，当前指令PC+rel附近的128B地址。  
> 前三个指令可以直接给出行号。  
> 间接转移指令，可以根据A寄存器中不同的值进行跳转，散转指令，功能相当于C中的swich语句。  

* **条件转移指令-A寄存器判断**  
	JZ rel;A==0则转移，否则顺序执行。
	JNZ rel;A！=0则转移，否则顺序执行。
	JZ 标号; 转移到标号出。
> 当前PC值=PC+指令长度  
> 转移后的PC值=当前PC值+rel  

* **条件转移指令-比较转移**  
	CJNE A,#data，rel/标号;比较不等转移  
* **调用返回指令**  
	ACALL addr11;指令长度两个字节  
	LCALL addr16;指令长度三个字节  
	RET;子程序返回指令  
	RETI;中断子程序返回指令  
> 调用子程序，原来的PC指针值压栈，返回时，出栈执行。  
> 嵌套太多是堆栈溢出，压栈出栈配对。

* **空操作指令**  
	NOP;指令执行时间是一个机器周期，用来做软件延时。


## &gt;位操作指令  

------

> 由位处理器负责运算    
> 可以进行位操作的区域20H-2FH，特殊功能寄存器都可以。  
> CY自动用作位累加器  
> 字节地址、寄存器名字后面添加点操作运算符，对位进行操作psw.4;  
> 直接使用位名称（一般特殊功能寄存器都有相应的位名称，只是不知道）  
> 可以直接定义位地址  

* **位传送指令**  
	MOV C,bit; bit to C   
	MOV bit,C; C->bit
> 实现了位累加器CY和其他地址之间的数据传递  
> C代表了PSW.CY或者PSW.C  


* **位清零指令**  
	CLR C;  
	CLR bit;  
	SETB bit;  
	SETB C;  置位为1；
* **位逻辑运算指令**  
	ANL C,bit;  
	ANL C,/bit;  
	ORL C,bit;
	CPL C;

* **位条件转移指令**  
	JC rel；
	JNC rel；根据CY判断是否转移
	JB bit,rel;  
	JNB bit,rel;  根据bit判定是否转移
	JBC bit，rel 根据bit判定是否转移，判定后该位清零。
	