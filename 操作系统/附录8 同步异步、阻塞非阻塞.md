# 同步异步、阻塞非阻塞、网络编程与并行编程

> 参考文献
> * [https://www.zhihu.com/question/19732473/answer/14413599](https://www.zhihu.com/question/19732473/answer/14413599)
> * [https://www.cnblogs.com/shiysin/articles/10689761.html](https://www.cnblogs.com/shiysin/articles/10689761.html)
> * [https://blog.csdn.net/jolin678/article/details/49611587](https://blog.csdn.net/jolin678/article/details/49611587)
> * [https://blog.csdn.net/qq_40989769/article/details/110481553](https://blog.csdn.net/qq_40989769/article/details/110481553)



## 1 进程通信的方式——同步异步、阻塞非阻塞

### 同步异步

* 同步与异步关注的是消息通信机制。是**两个进程之间的关系**。
* 同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。
* 异步，当一个异步过程调用发出后，调用就直接返回，调用者不会立刻得到结果。被调用者通过状态、通知和回调函数来通知调用者。

### 阻塞非阻塞


* 阻塞和非阻塞关注的是程序在等待调用结果时的状态。是**一个进程的本身的状态**。
* 阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
* 非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。

## 2 设备IO的方式——同步异步、阻塞非阻塞
### nodejs中相关定义

* **同步式I/O（Synchronous I/O）或阻塞式I /O （Blocking I/O）**。线程/进程在执行中如果遇到磁盘读写或网络通信（统称为I/O 操作），通常要耗费较长的时间，这时 操作系统会剥夺这个线程/进程的CPU 控制权，使其暂停执行，同时将资源让给其他的工作线程，这种线程调度方式称为阻塞 。当I/O 操作完毕时，操作系统将 这个线程的阻塞状态解除，恢复其对CPU的控制权，令其继续执行。  
* **异步式 I/O （Asynchronous I/O）或非阻塞式I/O （Non-blocking I/O）**。则针对所有I/O 操作不采用阻塞的策略。当线程 遇到I/O 操作时，不会以阻塞的方式等待I/O 操作的完成或数据的返回，而只是将I/O 请求发送给操作系统，继续执行下一条语句。当操作系统完成I /O 操作时，以事件的形式通知执行I/O 操作的线程，线程会在特定时候处理这个事件。为了处理异步I/O，线程必须有事件循环，不断地检查有没有未处 理的事件，依次予以处理。
* **并发方式**。阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过**多线程**。而非阻塞模式下，一个线程永远在执行计算操作，这个线程所使用的CPU 核心利用率永远是100%，**I/O 以事件的方式通知**。在阻塞模式下，多线程往往能提高系统吞吐量，因为一个线程阻塞时还有其他线程在工作，多线程可以让CPU 资源不被阻塞中的线程浪费。而在非阻塞模式下，线程不会被I/O 阻塞，永远在利用CPU。多线程带来的好处仅仅是在多核CPU 的情况下利用更多的核，而Node.js的单线程也能带来同样的好处。这就是为什么Node.js 使用了单线程、非阻塞的**事件编程模式**。

### 一种更深的理解——在看完五种IO模型之后的反思

* 同步和异步是针对**应用程序和内核**的交互而言的；
  * 同步指的是用户进程触发IO操作并等待或者轮询的去查看IO操作是否就绪。可以是阻塞等待也可以是非阻塞的轮询。
  * 异步是指用户进程触发IO操作以后便开始做自己的事情，而当IO操作已经完成的时候会得到IO完成的通知。
* 阻塞和非阻塞是针对于**进程在访问数据**的时候，根据IO操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作函数的实现方式；
  * 阻塞方式下读取或者写入函数将一直等待，
  * 非阻塞方式下，读取或者写入函数会立即返回一个状态值。

## 3 进程通信和设备IO的关系

1. 关于同步异步、阻塞非阻塞。交互方式，分别有两种应用。一种用在**进程间的同步和通信**上；一种用在**设备IO过程**中。必须要进行区分。

2. 当然两者似乎也有重合的部分。例如在socket编程（网络编程）网络进程通信过程中，即是一种**网络进程通信（两个远程进程）**，也是一种**网络IO过程（一个进程与网卡设备IO）**。可以看成两个远程的网络进程通信，也可以看成单个线程与本地网卡设备的IO过程。

3. 所以在某种程度上。可以把两个进程的通信，看成某一个用户进程的IO过程，而另一个进程看成是设备。

## 4 实现方式
### 同步阻塞通信
> 在此种方式下，用户进程在发起一个IO操作以后，必须等待IO操作的完成，只有当真正完成了IO操作以后，用户进程才能运行。

* java 传统的IO和socket网络编程，都是阻塞通信。接收端在接受到数据之前，一直处于阻塞状态。通过多线程实现并行编程。
* 在linux下，select/poll/epoll也是同步阻塞IO，也被称为事件IO，同时堵塞多个IO。不需要多线程，当某个IO可用时，发送IO事件，使用事件驱动的IO实现并行编程。
* 普通B/S模式（同步）：提交请求->等待服务器处理->处理完毕返回 这个期间客户端浏览器不能干任何事。也是通过开启多个浏览器线程实现并行编程。

### 同步非阻塞
> 在此种方式下，用户进程发起一个IO操作以后边可返回做其它事情，但是用户进程需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问，从而引入不必要的CPU资源浪费。其中目前JAVA的NIO就属于同步非阻塞IO。

* 用户进程轮训IO信号，虽然没有阻塞，但是在循环中一直确认IO是否完成。效率很低。


### 异步非阻塞通信
> 在此种模式下，用户进程只需要发起一个IO操作然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的IO读写操作，因为真正的IO读取或者写入操作已经由内核完成了。目前Java中还没有支持此种IO模型

* node.js是单线程的异步非阻塞(事件循环检测通知的机制)；
* windows完全端口是机器上有几个cpu创建几个线程的异步非阻塞机制（多线程池 + 事件触发机制)
* linux epoll也是创建合理的线程池的异步非阻塞机制（线程池+记录活跃socket + 边缘事件触发机制 + mmap文件映射内存减少复制开销)。
* ajax请求（异步）: 请求通过事件触发->服务器处理（这是浏览器仍然可以作其他事情）->处理完毕


### 异步阻塞通信

> 此种方式下是指应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序，这其实就是同步和异步最关键的区别，同步必须等待或者主动的去询问IO是否完成，那么为什么说是阻塞的呢？因为此时是通过select系统调用来完成的，而select函数本身的实现方式是阻塞的，而采用select函数有个好处就是它可以同时监听多个文件句柄，从而提高系统的并发性！


### 实现并行编程的几种方法

1. java 多线程
2. nodejs 异步回调
3. linux IO复用。epoll事件回调

> 这里所谓的什么机制、什么方法。都是设计模式的一部分。通过某种设计模式，实现并行编程：异步回调模式、事件回调模式等。