## 动态交互建模

### 目录


## 1概念
### 1.1 动态模型概念
* 描述了被建模系统的控制行为以及构件的交互顺序。对象内部的动态模型——有限状态机模型。对象之间的动态模型——交互图或通信图。
* 基于用例建模和问题域的静态建模。


## 2对象交互建模

### 2.1 通信图
* 描述了一组对象如何通过对象间的消息传递来实现交互。
* 每一个用例对应一个通信图。通信图中的对象都是用例包含的对象，对象之间的消息发送序列由编号来描述。通信图中的消息序列与用例描述中参与者与系统的交互序列相对应。

### 2.2 序列图
* 按照时间顺序展现了对象之间的交互。可以描述循环和迭代的过程。
* 不需要编号，从上到下，表示了消息的先后顺序。
* 序列图的优缺点
    * 优： 清楚地显示对象间的消息传递序列
    * 优： 对设计对象操作的执行逻辑有益
    * 缺： 不易表述对象的关联
    * 缺： 涉及多个对象的复杂序列图及使用了循环和判定逻辑的序列图不易阅读
* 通信图的优缺点
    * 优： 清楚地展现了对象的布局及其关联关系
    * 优： 易于平滑过渡到软件架构的设计
    * 缺： 表示消息序列直观性差（用编号）
    * 缺： 对设计对象操作的执行逻辑帮助有限

### 2.3 消息序列

* 交互图上的交互序列描述了用例中的一个场景。
* 消息标签：序列表达式：消息名称（消息参数）
* 消息序列的编号：用例ID+整数（外部事件）+小数（内部事件）+第二个字母（并发分支情况）
```
A1, A1.1, A1.2, A1.3, A1.4, ……
A2, A2.1, A2.2, A2.3, A2.4, ……
A2.1a, A2.1a.1, A2.1a.2, ……
表示用例A被参与者两次发起交互序列，在消息A2处发
起了并发消息序列分支。

A1, A1.1, A1.2, A1.3, A1.4, ……
A2, A2.1[Normal], A2.2, A2.3, A2.4, ……
A2.1a[Error], A2.1a.1, A2.1a.2, ……
表示用例A被参与者两次发起交互序列，在消息A2处发
起了条件分支的消息序列，标记为A2.1[Normal]的消息
序列是正常序列，标记为A2.1a[Error]的消息序列是可
替换的消息序列。
```


## 3 动态交互建模——无状态交互建模

### 3.1 目的
* 分析对象之间如何通过交互来实现用例

### 3.2 步骤
* 开发用例模型
* 确定在实现时，所需要的用例对象。
    * 确定边界对象。
    * 确定内部软件对象。
* 确定消息通信序列。主序列通信图
* 确定可替换序列。备选序列通信图。合成通用通信图。


### 3.3 实例

## 4 动态交互建模——有限状态机

### 4.1 概念
包含有限个状态的概念化机器。对系统或者对象的控制视图进行建模。有限状态机的行为既与当前输入有关，也与之前执行的事件有关。可能导致输出，事件具有原子性不持续。状态是一种可以识别的、存在于一段时间内的情况，转化时间忽略不计。



### 4.2 ECA机制


```
graph LR
E(event)-->|触发| C(Condition)
C(Condition)-->|执行| A(Action)
```


### 4.3 状态图

##### 事件和条件

* 通过使用警戒条件，能够使状态转换具有条件性。
* 表示格式  ==*事件[条件]*== 条件是布尔表达式，条件为真时，发生状态转变。
* 事件可以不必立即导致状态变化，而是作为以后事件（状态转化）的警戒条件。

##### 动作

* 表示格式 ==*事件/动作*==
* 状态转换的结果是动作的执行,动作执行后，状态转化完毕。动作持续时间忽略不计。三类动作（状态转换动作、进入动作、退出动作）
* 进入动作： Entry/Start Cooking  进入此状态后执行的动作，但上一模块退出不一定执行。
* 退出动作： Exit/Stop Cooking 退出此状态时执行的动作，但下一模块进入不定执行。


### 4.4 层次化状态图

* 用来简化状态图，增强建模能力。
* 层次关系：分解和聚合。
* 层次化状态分解：引入符合状态，被分解为多个子状态。


##### 顺序华状态分解
* 子状态相互关联，且有先后顺序，顺序化状态分解。
* 当复合状态被分解为多个子状态时，必须保留进入和离开该复合状态的状态转换。

##### 正交状态图
* 用来从不同视角对同一对象状态进行建模。
* 高层次的状态可以分解为两个或者多个正交状态图。
* 当进入复合状态时，同时进入正交的多个状态图。
* 可以表示并发。

### 4.5 开发状态图的指导原则

* 状态名称必须反映可识别的情况或一段时间间隔。
* 必须能从某个状态退出，可以没有终止状态。
* 任何时刻只能处于一个状态（并发的状态可以处于多个状态把）
* 不能混淆事件和动作。事件是状态转变的原因，动作是状态转变的结果。
* 事件表示一个时刻，表示事情或者动作的结果。是由外部操作引起的。
* 动作是一个命令，瞬间执行，由系统执行。
* 条件是布尔值。


### 4.6 用例图到状态图
##### 转化步骤：
* 从用例中的一个场景出发，最好是主序列
* 考虑给定场景下外部事件的顺序，通过系统对事件的响应确定状态转换和状态
* 若一个动作与状态转换关联，则从一个状态转换为另一状态时触发该动作
* 动作靠系统对输入事件的响应来决定
* 考虑用例中的所有备选序列，获得所有可能的
外部事件
* 通过分析这些事件对系统的影响，添加新的状
态、状态转换和动作
* 一个状态图可能参与多个用例，此时每个用例
对应一个部分状态图，将部分状态图整合形成
完整状态图
* 对得到的扁平状态图进行层次化处理
* 也可以采用自顶向下的方法先开发高层状态图，然后分解

## 5 状态相关的动态交互建模

### 5.1 建模步骤
* 确定边界对象：负责发送事件，引起内部状态转换。
* 确定状态相关的控制对象。
* 确定其他软件对象。
* 确定主序列中的对象交互。
* 确定状态图的执行。
* 考虑备选序列的场景。