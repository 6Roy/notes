## 1 include

### 基本使用
```
include<iostream>
include"a.cpp"
```

### 原理

* #include是C++预处理器的一部分。预处理器处理程序的源代码，是在编译器之前运行。#include只接受一个参数：头文件名。预处理器用指定的头文件的内容替代每个include。
* include的作用是从源代码上的复制粘贴。不会进行逻辑处理，而是直接插入引用的部分。
* 一个程序的头文件.h不是为了给自己用的，而是为了给其他程序用的。所以，在给别人使用的.h中声明extern int的全局变量很重要。

## 2 extern
### 基本使用
* 声明一个变量
* 不带定义，不申请空间。

```
extern int i;
```

### 原理

* 语句：extern int a; 仅仅是一个变量的声明，其并不是在定义变量a，也并未为a分配空间。变量a在所有模块中作为一种全局变量只能被定义一次，否则会出错。

* 通常来说，在模块的头文件中对本模块提供给其他模块引用的函数和全局变量以关键字extern声明。例如，如果模块B要引用模块A中定义的全局变量和函数时只需包含模块A的头文件即可。这样模块B中调用模块A中的函数时，在编译阶段，模块B虽然找不到该函数，但并不会报错；它会在链接阶段从模块A编译生成的目标代码中找到该函数。
* 函数的声明extern关键词可有可无，因为函数本身不加修饰的话就是extern。全局变量在外部使用的时候，extern关键字是必须的。局部变量的声明不能有extern，且局部变量在运行时才在堆栈部分分配内存。
* 全局变量是在函数外部声明的变量。函数名本身在函数外部，也是全局的。
* 修饰声明全局变量或函数，其声明的变量和函数可以在其它模块（文件）中使用，注意，这只是一个声明而不是定义，具体的定义要在具体的模块中完成。


## 3 const

### 基本使用

```
const int bufersize = 512
```

### 原理

* 它的值不能被改变，不能进行赋值操作，只能进行初始化。
* 默认情况下，const值尽在文件中有效。编译器在编译过程中会把用到该变量的地方都替换成对应的值。

## 4 typedef

### 基本使用


typedef使用最后一个名词作为名字
```
typedef double hello;
typedef double* p;
typedef int h[81];
typedef　struct　tag
{
int　iNum;
long　lLength;
}MyStruct;//定义了结构体；typedef struct tag MyStruct
```
### 原理

* typedef使用最后一个名词作为名字

## 5 using

### 基本使用

```
using SI = Sales_item;
```

### 原理

* 类型别名和类型等价


## 6 auto
### 基本使用
* 编译器自动分析类型

```
auto item = val1 +val2
```

## 7 decltype
### 基本使用

```
decltype(f()) sum =x;
```

### 原理
* 根据表达式推断类型，而不会计算表达式。类型推断。

> 略过的constexp,