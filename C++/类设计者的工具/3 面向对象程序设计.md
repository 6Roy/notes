# 面向对象程序设计

> 参考文献
> * [多态的三种方式](https://blog.csdn.net/qq_41306849/article/details/109081625)
> * [虚继承和虚基类](http://c.biancheng.net/view/2280.html)


> 面向对象的基本概念
> * 数据抽象和封装（在语法基础部分讲解过了）
> * 继承
> * 多态（动态绑定）


## 1 OOP：概述

### 面向对象程序设计

* 核心思想：
  * 数据抽象：类的接口与实现分离。
  * 继承：定义相似的类型，对相似的关系建模。实现代码重用。
  * 动态绑定：可以在以一定程度上忽略相似类型的区别。

### 继承概念（继承）

* 继承：联系在一起的类构成以中层次关系
* 基类：层次关系的根部
* 派生类：其他类则直接或间接地从基类继承而来。

* 派生类与基类的函数继承：
  * 与类型相关的函数。基类与派生类类型不同，需要重写。
  * 与类型无关的函数。派生类直接继承，不需要修改。

* 类派生列表：派生类通过类派生列表，明确指出它的基类。

```
class Dog:public Animal{
public:
    double price()const override;
}
```

* 派生类可以通过**override关键字**注明改写基类的函数。



### 动态绑定（多态）

* 在运行时选择函数的版本。通过使用动态绑定，我们能用同一段代码分别处理Animal和Dog的对象。

## 2 继承与多态详解
## 2.1 继承

### 定义基类
```
class Quote{
public:
    Quote() = default;
    Quote(string book,double sales_price):book_no(book),price(sales_price){};
    string isbn()const{
        return this.book_no;
    }
    virtual double net_price(int n)const{
        return n*price;
    }
    virtual ~Quote()=default;
private:
    string book_no;
protected:
    double price;
};
```
### 定义派生类
```
class Bulk_quote:public Quote{
public:
    Bulk_quote()=default;
    Bulk_quote(string,double,int,double);
    double net_price(int n)const override;
private:
    int mn_qty = 0;
    double discount=0.0;
};
Bulk_quote::Bulk_quote(string book,double p,int qty,double disc):Quote(book,p),min_qty(qty),discount(disc){}//委托基类构造函数
```


### 继承方式

* 单一继承：继承一个父类，这种继承称为单一继承，一般情况尽量使用单一继承，使用多重继承容易造成混乱易出问题
* 多重继承：继承多个父类，类与类之间要用逗号隔开，类名之前要有继承权限，假使两个或两个基类都有某变量或函数，在子类中调用时需要加类名限定符如c.a::i = 1；
* 菱形继承：多重继承掺杂隔代继承1-n-1模式，此时需要用到虚继承，例如 B，C虚拟继承于A，D再多重继承B，C，否则会出错


### 继承权限
* 继承权限：继承方式规定了如何访问继承的基类的成员。继承方式指定了派生类成员以及类外对象对于从基类继承来的成员的访问权限

![](image/2021-03-07-14-26-29.png)

### 注意事项

* 基类的静态成员变量，在整个继承体系中只存在该成员的唯一定义。
* 派生类的声明中包含类名，但不能包含派生列表。

### final关键字

* 使用**关键字final**说明符防止类被继承


* 使用**关键字final**说明符防止函数被重写
```
class A final{
    void f1(int) const;
};
```

## 2.2 多态

### 多态分类

1. 静态多态，是只在编译期间确定的多态。静态多态在编译期间，根据函数参数的个数和类型推断出调用的函数。静态多态有两种实现的方式
   1. 重载。（函数重载）
   2. 模板。
2. 动态多态，是运行时多态。通过虚函数机制实现（也称为重写override），使用父类的指针或者是引用，调用一个虚函数时，会根据其指向的具体对象确定调用的函数。基类和子类维护一个虚函数表，对象当中包含的虚指针，指向基类或子类的虚函数表。如果子类没有重写父类的虚函数则会直接调用父类的方法，否则调用子类重写的方法。


### 多态原理

* （对象的多态性）使用基类的引用或指针调用一个函数时。无法确定该函数作用的对象是什么类型。因为它可能是一个基类的对象，也可能是一个派生类的对象。
* （函数的多态性）如果该函数是虚函数，则直到运行时才会决定执行哪个版本。判断的依据是引用或指针所绑定的对象真实类型。
* 函数绑定。对非虚函数的调用在编译时进行绑定。我们通过对象进行的函数调用也在编译时绑定。对象的类型是确定不变的。

> 也就是说多态性体现在指针和引用的不确实能够性上。但对象在内存中的状态是确定的。当且晋档通过指针或引用调用虚函数是，才会在运行时解析该调用，也只有在这种情况下对动态类型才有可能与静态类型不同。

```
    Bulk_quote a();//定义了对象a。这时候，无法触发多态。
    Bulk_quote* b = new Bulk_quote();//指针可以指向不同的类型的对象。
    Bulk_quote &b = a;//引用可以指向不同类型的对象。
```

### 重写与重定义对比
* 重定义：基类中没有声明函数是虚函数。派生类中对普通函数进行了重定义。只是作用域上的覆盖，没有触发多态和动态绑定。
* 重定义不能触发动态多态。无论指针或引用绑定的是什么对象，都会根据指针或引用的类型，调用该类型的函数。而不是使用虚指针查找虚函数表。只有调用虚函数的时候，才会去根据对象的虚函数指针，查找类中的虚函数表。

```
class A{
public:
    int a;
    A():a(10){};
    int real_ex(){
        return a;
    }
    virtual int virtual_ex(){
        return a;
    }
};

class B:public A{
public:
    int b;
    B():b(20){};
    int real_ex(){//重定义A的函数
        return b;
    }
    virtual int virtual_ex(){//重写A的函数
        return b;
    }
};
int main(){

    Quote p(Bulk_quote());//直接初始化，拷贝构造函数
    Quote q = Bulk_quote();//赋值初始化，拷贝构造函数
    
    // B test_b;
    // A* test = &test_b;
    A* test=new B();
    cout<<test->real_ex()<<endl;//B重定义了函数。但是A类型的指针，调用基类的函数。
    cout<<test->virtual_ex()<<endl;//B重写类函数。B类型的对象，动态绑定，调用了派生类的函数。
    return 0;
}
```
### 实现条件
运行时多态的条件：
* 必须是集成关系
* 基类中必须包含虚函数，并且派生类中一定要对基类中的虚函数进行重写。
* 通过基类对象的指针或者引用调用虚函数。

### 注意事项

以下函数不能作为虚函数
1. 友元函数，它不是类的成员函数
2. 全局函数
3. 静态成员函数，它没有this指针
3. 构造函数，拷贝构造函数，以及赋值运算符重载（可以但是一般不建议作为虚函数）

### 实现原理
//参考虚函数。


## 2.3 类型转换
### 静态类型和动态类型

* 静态类型在编译时已知。是指针或者引用的类型。
* 动态类型表示内存中的对象类型。动态类型直到运行时才可知。


### 派生类到基类的类型转换。

* 把派生类对象当成基类对象来使用。将基类的指针或引用绑定到派生类对象。

### 基类到派生类的类型转换。

* 不存在从基类向派生类的隐式转换。



### 对象之间不存在类型转换

* 所谓的**类型转换只是指针或者引用的类型转换**，对象本身的类型，没有发生改变。
* 但是派生类可以赋值给基类的对象。基类的拷贝构造函数和移动构造函数，接受一个引用对象。将派生类对象赋值给引用对象，实现基类的初始化。实际生成的是一个基类对象。
* 这里并非多态，而是执行拷贝构造函数。创建了一个基类对象

```
class A{

}
class B:public A{

}
B b();
A a = b;//可以赋值给基类对象。执行拷贝构造函数。并非多态。
A aa(b);//直接初始化，执行基类的拷贝构造函数。并非多态。
```

### 转换规则总结

* 从派生类向基类的类型转换只对指针或引用有效。是指针或引用的类型转换，而不是其指向的对象的类型发生改变。
* 基类向派生类不存在隐式类型转换
* 派生类向基类的类型转换也可能会由于访问受限而变得不可行。

## 3 虚函数

### 虚函数的定义
* 虚函数：基类希望它的派生类自定义适合自身的版本。为了实现多态

```
class Animal{
public:
    virtual double price(int n)const;
}
```

### 虚函数的原理
* 除了构造函数的非静态函数都可以是虚函数。
* 关键字virtual智能出现在类内部的声明语句之前。不能出现在类外部的函数定义。
* 如果把一个函数声明成虚函数，则该函数在派生类中也是隐式的虚函数。（即派生类的派生类，也需要重写次函数）
* 派生类可以不用重写虚函数。
* 派生类可以在它重写的虚函数前使用**virtual关键字**

### 回避虚函数的机制

* 类中的数据成员和成员函数是相互独立的。两者没有必然的联系。
* 成员函数通过this指针访问对象的数据成员。在继承体系中，this指针的指向是可以改变。即可以用派生类对象的this指针传递给基类的函数，从而实现派生类调用基类函数的方法。
* 调用是不进行动态绑定，而是强迫执行虚函数的某个特定版本。通过域作用运算符实现。
```
//强制调用基类中定义的函数
Bulk_quote *baseP = Bulk_quote();
double u = baseP->Quote::net_price();
```
### 纯虚函数和抽象基类

```
 virtual void Eat() = 0;
```
* 一个纯虚函数无须定义，在函数体的位置书写=0，就可以讲一个虚函数说明为纯虚函数。只能出现在类内部的函数声明语句出。在类的内部必须没有定义，在类的外部可以定义纯虚函数。
* 含有纯虚函数的类是抽象基类。纯虚函数相当于接口，不能创建抽象基类的对象。
* 派生类构造函数只初始化它的直接基类。


### 虚函数表和虚指针原理

```C++
class A
{
public:
    virtual void f();
    virtual void g();
private:
    int a
};
 
class B : public A
{
public:
    void g();
private:
    int b;
};//A、B实现省略
```
* 因为A有virtual void f（）和g（），所以编译器为A类准备了一个虚函数表vtableA，内容如下：


```
A::f 的地址
A::g 的地址
```

* B因为继承了A，所以编译器也为B准备了一个虚函数表vtableB，内容如下：
```
A::f 的地址
B::g 的地址
```
> 注意：因为B::ｇ是重写了的，所以B的虚表的g放的是B::g的入口地址，但是f是从上面的A继承下来的，所以f的地址是A::f的入口地址。

* 某处有语句 B bB;的时候，编译器分配空间时，除了A的int a，B的成员int b；以外，还分配了一个虚指针vptr，指向B的虚函数表vtableB，bB的布局如下：

```
vptr ： 指向B的虚表vtableB
int a： 继承A的成员
int b： B成员
```

## 4 访问控制与继承

### 访问控制
* 派生类能够访问公有成员和受保护的成员。
* 派生类不能访问私有成员。

public:
private:
protected:

### 继承类型

* public 公有继承
* private私有继承

### 默认的集成保护级别

* class关键字定义的派生类，默认是私有继承
* struct关键字定义的派生类，默认是公有继承

## 5 继承中的类作用域

### 作用域
* 当存在继承关系是，派生类的作用域嵌套在基类的作用域内。如果一个名字在派生类的作用域内无法解析，编译器在外层的基类作用域中寻找改名字的定义。


### 编译时名字查找

* 引用或指针的静态类型决定了该对象有哪些成员是可见的。一个基类的引用和指针只能访问基类的成员。即是动态对象是其派生类。

### 名字冲突与继承
* 派生了重用定义在直接基类或间接基类中的名字，会屏蔽定义在外层作用域基类中的名字

### 访问隐藏的成员

* 通过作用域运算符来使用一个被隐藏的基类成员。


## 6 虚继承和虚基类

### 多继承
* 多继承（Multiple Inheritance）是指从多个直接基类中产生派生类的能力，多继承的派生类继承了所有父类的成员。尽管概念上非常简单，但是多个基类的相互交织可能会带来错综复杂的设计问题，命名冲突就是不可回避的一个。

* 多继承时很容易产生命名冲突，即使我们很小心地将所有类中的成员变量和成员函数都命名为不同的名字，命名冲突依然有可能发生，比如典型的是菱形继承，如下图所示：

### 菱形继承

![](image/2021-03-07-15-55-33.png)

* 类 A 派生出类 B 和类 C，类 D 继承自类 B 和类 C，这个时候类 A 中的成员变量和成员函数继承到类 D 中变成了两份，一份来自 A-->B-->D 这条路径，另一份来自 A-->C-->D 这条路径。

* 下面是菱形继承的具体实现：

```
//间接基类A
class A{
protected:
    int m_a;
};
//直接基类B
class B: public A{
protected:
    int m_b;
};
//直接基类C
class C: public A{
protected:
    int m_c;
};
//派生类D
class D: public B, public C{
public:
    void seta(int a){ m_a = a; }  //命名冲突
    void setb(int b){ m_b = b; }  //正确
    void setc(int c){ m_c = c; }  //正确
    void setd(int d){ m_d = d; }  //正确
private:
    int m_d;
};
int main(){
    D d;
    return 0;
}
```
* 这段代码实现了上图所示的菱形继承，第 25 行代码试图直接访问成员变量 m_a，结果发生了错误，因为类 B 和类 C 中都有成员变量 m_a（从 A 类继承而来），编译器不知道选用哪一个，所以产生了歧义。

* 为了消除歧义，我们可以在 m_a 的前面指明它具体来自哪个类：
```
void seta(int a){ B::m_a = a; }
```
* 这样表示使用 B 类的 m_a。当然也可以使用 C 类的：
```
void seta(int a){ C::m_a = a; }
```

### 虚继承（Virtual Inheritance）

* 为了解决多继承时的命名冲突和冗余数据问题，C++ 提出了虚继承，使得在派生类中只保留一份间接基类的成员。

* 在继承方式前面加上 virtual 关键字就是虚继承，请看下面的例子：

```
//间接基类A
class A{
protected:
    int m_a;
};
//直接基类B
class B: virtual public A{  //虚继承
protected:
    int m_b;
};
//直接基类C
class C: virtual public A{  //虚继承
protected:
    int m_c;
};
//派生类D
class D: public B, public C{
public:
    void seta(int a){ m_a = a; }  //正确
    void setb(int b){ m_b = b; }  //正确
    void setc(int c){ m_c = c; }  //正确
    void setd(int d){ m_d = d; }  //正确
private:
    int m_d;
};
int main(){
    D d;
    return 0;
}
```
* 这段代码使用虚继承重新实现了上图所示的菱形继承，这样在派生类 D 中就只保留了一份成员变量 m_a，直接访问就不会再有歧义了。

* 虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类（Virtual Base Class），本例中的 A 就是一个虚基类。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。

* 现在让我们重新梳理一下本例的继承关系，如下图所示：

![](image/2021-03-07-15-58-59.png)

* 观察这个新的继承体系，我们会发现虚继承的一个不太直观的特征：必须在虚派生的真实需求出现前就已经完成虚派生的操作。在上图中，当定义 D 类时才出现了对虚派生的需求，但是如果 B 类和 C 类不是从 A 类虚派生得到的，那么 D 类还是会保留 A 类的两份成员。

* 换个角度讲，虚派生只影响从指定了虚基类的派生类中进一步派生出来的类，它不会影响派生类本身。

### 虚继承在C++标准库中的实际应用
* 在实际开发中，位于中间层次的基类将其继承声明为虚继承一般不会带来什么问题。通常情况下，使用虚继承的类层次是由一个人或者一个项目组一次性设计完成的。对于一个独立开发的类来说，很少需要基类中的某一个类是虚基类，况且新类的开发者也无法改变已经存在的类体系。

* C++标准库中的 iostream 类就是一个虚继承的实际应用案例。iostream 从 istream 和 ostream 直接继承而来，而 istream 和 ostream 又都继承自一个共同的名为 base_ios 的类，是典型的菱形继承。此时 istream 和 ostream 必须采用虚继承，否则将导致 iostream 类中保留两份 base_ios 类的成员。


![](image/2021-03-07-16-00-43.png)

### 虚基类成员的可见性

* 因为在虚继承的最终派生类中只保留了一份虚基类的成员，所以该成员可以被直接访问，不会产生二义性。此外，如果虚基类的成员只被一条派生路径覆盖，那么仍然可以直接访问这个被覆盖的成员。但是如果该成员被两条或多条路径覆盖了，那就不能直接访问了，此时必须指明该成员属于哪个类。

* 以图2中的菱形继承为例，假设 A 定义了一个名为 x 的成员变量，当我们在 D 中直接访问 x 时，会有三种可能性：
  * 如果 B 和 C 中都没有 x 的定义，那么 x 将被解析为 A 的成员，此时不存在二义性。
  * 如果 B 或 C 其中的一个类定义了 x，也不会有二义性，派生类的 x 比虚基类的 x 优先级更高。
  * 如果 B 和 C 中都定义了 x，那么直接访问 x 将产生二义性问题。

